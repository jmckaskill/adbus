<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>adbus: adbus_Connection Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>adbus_Connection Struct Reference</h1><!-- doxytag: class="adbus_Connection" -->
<p>Client message dispatcher.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacd39cd29946120c6e56f6c6d91eec3e"></a><!-- doxytag: member="adbus_Connection::adbus_conn_new" ref="aacd39cd29946120c6e56f6c6d91eec3e" args="(adbus_ConnectionCallbacks *cb, void *user)" -->
<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#aacd39cd29946120c6e56f6c6d91eec3e">adbus_conn_new</a> (<a class="el" href="structadbus__ConnectionCallbacks.html">adbus_ConnectionCallbacks</a> *cb, void *user)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd139a2aa96cc228c564012d5de38b95"></a><!-- doxytag: member="adbus_Connection::adbus_conn_ref" ref="acd139a2aa96cc228c564012d5de38b95" args="(adbus_Connection *connection)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#acd139a2aa96cc228c564012d5de38b95">adbus_conn_ref</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *connection)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments the connection ref count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33de45ed2fb0a9faf667f43fc1b9a2cc"></a><!-- doxytag: member="adbus_Connection::adbus_conn_deref" ref="a33de45ed2fb0a9faf667f43fc1b9a2cc" args="(adbus_Connection *c)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#a33de45ed2fb0a9faf667f43fc1b9a2cc">adbus_conn_deref</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrements the connection ref count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#a0fabe2dd65fdc0b05a5571655dac6d08">adbus_conn_send</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, <a class="el" href="structadbus__Message.html">adbus_Message</a> *message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a message on the connection.  <a href="#a0fabe2dd65fdc0b05a5571655dac6d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#a613ad9b713130293f3fb4e5824ae70d1">adbus_conn_serial</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a serial that can be used for sending messages.  <a href="#a613ad9b713130293f3fb4e5824ae70d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93c73655b90209e91f62184ce72bbdd"></a><!-- doxytag: member="adbus_Connection::adbus_conn_dispatch" ref="ae93c73655b90209e91f62184ce72bbdd" args="(adbus_Connection *c, adbus_Message *message)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#ae93c73655b90209e91f62184ce72bbdd">adbus_conn_dispatch</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, <a class="el" href="structadbus__Message.html">adbus_Message</a> *message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dispatch a pre-parsed message. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#a163af2b28a24ca8c474a9e68cdf6100f">adbus_conn_parse</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, <a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume messages from the supplied buffer.  <a href="#a163af2b28a24ca8c474a9e68cdf6100f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">adbus_Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#afeef1d5935553474b8f055dcde28c0ea">adbus_conn_shouldproxy</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See if calling code should use <a class="el" href="structadbus__Connection.html#af26fb89e267785018a8e9eefa8195a78" title="Proxy a call over to the connection thread or call immediately if already on it.">adbus_conn_proxy()</a>.  <a href="#afeef1d5935553474b8f055dcde28c0ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#af26fb89e267785018a8e9eefa8195a78">adbus_conn_proxy</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, adbus_Callback callback, void *user)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Proxy a call over to the connection thread or call immediately if already on it.  <a href="#af26fb89e267785018a8e9eefa8195a78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#a4d731bb2636c148baaae12d689889fa2">adbus_conn_getproxy</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, adbus_ProxyCallback *cb, adbus_ProxyMsgCallback *msgcb, void **user)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get proxy functions for the current thread.  <a href="#a4d731bb2636c148baaae12d689889fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">adbus_ConnReply *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#aa1e9cded3183df6577a94354d8f994a7">adbus_conn_addreply</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, const <a class="el" href="structadbus__Reply.html">adbus_Reply</a> *reg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a reply with the connection.  <a href="#aa1e9cded3183df6577a94354d8f994a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Connection.html#afc04e7757687c7e486db6903ac5cf6d3">adbus_conn_removereply</a> (<a class="el" href="structadbus__Connection.html">adbus_Connection</a> *c, adbus_ConnReply *reply)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a reply from the connection.  <a href="#afc04e7757687c7e486db6903ac5cf6d3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Client message dispatcher. </p>
<p>The connection API can be split into four sections:</p>
<ol type="1">
<li>Getting data in/out.</li>
<li>Proxying messages from the connection to and from other threads.</li>
<li>Registering application callbacks via:<ol type="a">
<li>Binds: registers an interface on a path that can be introspected, have methods called on, properties set, etc.</li>
<li>Replies: registers a callback listening for method return or error message.</li>
<li>Matches: generic message matches that can be pushed through to the bus server. This is mostly used for matching signals.</li>
</ol>
</li>
<li>Connecting to the bus server.</li>
</ol>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="structadbus__Connection.html" title="Client message dispatcher.">adbus_Connection</a> does not handle the initial authentication with the bus server. This can be done using either the <a class="el" href="structadbus__Auth.html" title="Minimal SASL client and server to connect to DBUS.">adbus_Auth</a> module or a third party SASL library.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unless otherwise specificed all connection functions must be called on the connection thread and may not be called in a callback.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__adbus__Socket.html" title="Helper functions for connecting BSD sockets.">adbus_Socket</a>, <a class="el" href="structadbus__Auth.html" title="Minimal SASL client and server to connect to DBUS.">adbus_Auth</a>, <a class="el" href="structadbus__Bind.html" title="Data structure used to bind interfaces to a particular path.">adbus_Bind</a>, <a class="el" href="structadbus__Reply.html" title="Data structure to register for return and error messages from a method call.">adbus_Reply</a>, <a class="el" href="structadbus__Match.html" title="Data structure used to register general matches.">adbus_Match</a></dd></dl>
<h2><a class="anchor" id="in">
Getting Data In</a></h2>
<p>The connection itself has no idea how to get incoming data or messages. Instead the owner of the connection figures out how to get incoming data off of a socket and feeds it into the connection via <a class="el" href="structadbus__Connection.html#ae93c73655b90209e91f62184ce72bbdd" title="Dispatch a pre-parsed message.">adbus_conn_dispatch()</a> or <a class="el" href="structadbus__Connection.html#a163af2b28a24ca8c474a9e68cdf6100f" title="Consume messages from the supplied buffer.">adbus_conn_parse()</a>.</p>
<p>The simplest way of handing data off to the connection is to append data to an <a class="el" href="structadbus__Buffer.html" title="General purpose buffer and means to serialise dbus data with an associated signature...">adbus_Buffer</a> and then having the connection consume complete messages in the buffer via <a class="el" href="structadbus__Connection.html#a163af2b28a24ca8c474a9e68cdf6100f" title="Consume messages from the supplied buffer.">adbus_conn_parse()</a>. For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #define RECV_SIZE 64 * 1024</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> ReadSignalled()
    {
        <span class="comment">// Read all the data available</span>
        adbus_ssize_t read = RECV_SIZE;
        <span class="keywordflow">while</span> (read == RECV_SIZE)
        {
            <span class="comment">// adbus_buf_recvbuf() gives us a place at the end of the buffer</span>
            <span class="comment">// to hand off to recv where it can put the data</span>
            uint8_t* buf = adbus_buf_recvbuf(my_buffer, RECV_SIZE);
            read = recv(my_socket, RECV_SIZE, 0);
            adbus_buf_recvd(my_buffer, RECV_SIZE, read);
        }
  
        <span class="comment">// Hand the data off to the connection. If adbus_conn_parse returns </span>
        <span class="comment">// an error, we should disconnect the socket.</span>
        <span class="keywordflow">if</span> (<a class="code" href="structadbus__Connection.html#a163af2b28a24ca8c474a9e68cdf6100f" title="Consume messages from the supplied buffer.">adbus_conn_parse</a>(my_connection, my_buffer))
            <span class="keywordflow">return</span> -2;
  
        <span class="comment">// Propagate recv errors up</span>
        <span class="keywordflow">if</span> (read &lt; 0)
            <span class="keywordflow">return</span> -1;
  
        <span class="keywordflow">return</span> 0;
    }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__adbus__Socket.html" title="Helper functions for connecting BSD sockets.">adbus_Socket</a>, <a class="el" href="structadbus__Buffer.html" title="General purpose buffer and means to serialise dbus data with an associated signature...">adbus_Buffer</a>, <a class="el" href="structadbus__Connection.html#ae93c73655b90209e91f62184ce72bbdd" title="Dispatch a pre-parsed message.">adbus_conn_dispatch()</a>, <a class="el" href="structadbus__Connection.html#a163af2b28a24ca8c474a9e68cdf6100f" title="Consume messages from the supplied buffer.">adbus_conn_parse()</a></dd></dl>
<h2><a class="anchor" id="out">
Getting Data Out</a></h2>
<p>Outgoing data is sent via <a class="el" href="structadbus__ConnectionCallbacks.html#a3d01dc7c30661cbf175203bde5d85f32" title="This is a callback to send messages.">adbus_ConnectionCallbacks::send_message</a> set with <a class="el" href="structadbus__Connection.html#aacd39cd29946120c6e56f6c6d91eec3e" title="Creates a new connection.">adbus_conn_new()</a>. This is required to be always set.</p>
<p>For example: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span> <span class="keywordtype">int</span> SendMessage(<span class="keywordtype">void</span>* user, <a class="code" href="structadbus__Message.html" title="Container for parsed messages.">adbus_Message</a>* msg)
    {
        adbus_Socket* s = (adbus_Socket*) user;
        <span class="keywordflow">return</span> send(*s, msg-&gt;<a class="code" href="structadbus__Message.html#a83575b9e7cd7c7fff702811f2f0cf5aa" title="Beginning of message data (must be 8 byte aligned).">data</a>, msg-&gt;<a class="code" href="structadbus__Message.html#a43bd16961112e1a093adebbe9eacb37a" title="Size of message data.">size</a>, 0);
    }

    <a class="code" href="structadbus__Connection.html" title="Client message dispatcher.">adbus_Connection</a>* CreateConnection(adbus_Socket sock)
    {
        <a class="code" href="structadbus__ConnectionCallbacks.html" title="Structure to hold callbacks registered with adbus_conn_new().">adbus_ConnectionCallbacks</a> cbs = {};
        cbs.<a class="code" href="structadbus__ConnectionCallbacks.html#a3d01dc7c30661cbf175203bde5d85f32" title="This is a callback to send messages.">send_message</a> = &amp;SendMessage;
        <span class="keywordflow">return</span> <a class="code" href="structadbus__Connection.html#aacd39cd29946120c6e56f6c6d91eec3e" title="Creates a new connection.">adbus_conn_new</a>(&amp;cbs, (<span class="keywordtype">void</span>*) &amp;sock);
    }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structadbus__ConnectionCallbacks.html#a3d01dc7c30661cbf175203bde5d85f32" title="This is a callback to send messages.">adbus_ConnectionCallbacks::send_message</a>, <a class="el" href="structadbus__Connection.html#aacd39cd29946120c6e56f6c6d91eec3e" title="Creates a new connection.">adbus_conn_new()</a></dd></dl>
<h2><a class="anchor" id="proxy">
Proxying Messages To/From the Connection Thread</a></h2>
<p>In multithreaded applications, the connection parsing and dispatch will be on a given thread, but we often want to register objects and callbacks for all of the application's thread on the one thread. The way we get around this is to proxy all messages and requests for registrations to and from the connection thread.</p>
<p>This proxying of messages to and fro is done via the proxy callbacks setup in <a class="el" href="structadbus__Connection.html#aacd39cd29946120c6e56f6c6d91eec3e" title="Creates a new connection.">adbus_conn_new()</a>. See proxy, should_proxy, get_proxy, and block in <a class="el" href="structadbus__ConnectionCallbacks.html" title="Structure to hold callbacks registered with adbus_conn_new().">adbus_ConnectionCallbacks</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structadbus__ConnectionCallbacks.html" title="Structure to hold callbacks registered with adbus_conn_new().">adbus_ConnectionCallbacks</a></dd></dl>
<h2><a class="anchor" id="registrations">
Binds, Matches, and Replies</a></h2>
<p>See <a class="el" href="structadbus__Bind.html" title="Data structure used to bind interfaces to a particular path.">adbus_Bind</a>, <a class="el" href="structadbus__Match.html" title="Data structure used to register general matches.">adbus_Match</a>, and <a class="el" href="structadbus__Reply.html" title="Data structure to register for return and error messages from a method call.">adbus_Reply</a>.</p>
<h2><a class="anchor" id="bus">
Bus Server</a></h2>
<p>By default the connection will not connect to the bus server (specifically it does not send the Hello message), until adbus_conn_connect() is called. This is especially useful for multithreaded applications that want to create a connection, register all of their objects on the various app threads, and then finally connect to the bus. This then avoids race conditions when other applications try to call method for not yet registered objects.</p>
<p>Once the server responds to the hello message adbus_conn_isconnected() will return true and adbus_conn_uniquename() will return the assigned name.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>adbus_conn_connect(), adbus_conn_isconnected(), adbus_conn_uniquename() </dd></dl>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa1e9cded3183df6577a94354d8f994a7"></a><!-- doxytag: member="adbus_Connection::adbus_conn_addreply" ref="aa1e9cded3183df6577a94354d8f994a7" args="(adbus_Connection *c, const adbus_Reply *reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">adbus_ConnReply * adbus_conn_addreply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structadbus__Reply.html">adbus_Reply</a> *&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a reply with the connection. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This should only be called on the connection thread. If not on the connection thread consider using adbus_state_addreply(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4d731bb2636c148baaae12d689889fa2"></a><!-- doxytag: member="adbus_Connection::adbus_conn_getproxy" ref="a4d731bb2636c148baaae12d689889fa2" args="(adbus_Connection *c, adbus_ProxyCallback *cb, adbus_ProxyMsgCallback *msgcb, void **user)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adbus_conn_getproxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adbus_ProxyCallback *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adbus_ProxyMsgCallback *&nbsp;</td>
          <td class="paramname"> <em>msgcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>user</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get proxy functions for the current thread. </p>
<p>The arguments may be null if that value is not needed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>adbus_ConnectionCallbacks::get_proxy </dd></dl>

</div>
</div>
<a class="anchor" id="a163af2b28a24ca8c474a9e68cdf6100f"></a><!-- doxytag: member="adbus_Connection::adbus_conn_parse" ref="a163af2b28a24ca8c474a9e68cdf6100f" args="(adbus_Connection *c, adbus_Buffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adbus_conn_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume messages from the supplied buffer. </p>
<p>This will remove all complete messages from the beginning of the buffer, but it will leave incomplete messages in the buffer. These should be appended to once more data comes in and then recall this function. </p>

</div>
</div>
<a class="anchor" id="af26fb89e267785018a8e9eefa8195a78"></a><!-- doxytag: member="adbus_Connection::adbus_conn_proxy" ref="af26fb89e267785018a8e9eefa8195a78" args="(adbus_Connection *c, adbus_Callback callback, void *user)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adbus_conn_proxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adbus_Callback&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Proxy a call over to the connection thread or call immediately if already on it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structadbus__Connection.html#afeef1d5935553474b8f055dcde28c0ea" title="See if calling code should use adbus_conn_proxy().">adbus_conn_shouldproxy()</a>, <a class="el" href="structadbus__ConnectionCallbacks.html#a31bc233e727e64151835436138ae7ba1" title="Callback to send messages across to the connection thread.">adbus_ConnectionCallbacks::proxy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc04e7757687c7e486db6903ac5cf6d3"></a><!-- doxytag: member="adbus_Connection::adbus_conn_removereply" ref="afc04e7757687c7e486db6903ac5cf6d3" args="(adbus_Connection *c, adbus_ConnReply *reply)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adbus_conn_removereply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adbus_ConnReply *&nbsp;</td>
          <td class="paramname"> <em>reply</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a reply from the connection. </p>
<p>If in C code, you should probably use <a class="el" href="structadbus__State.html" title="Helper class to manage connection services (binds, matches and replies).">adbus_State</a> rather than calling this directly as it manages the disconnects and thread issues.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This should only be called on the connection thread.</dd>
<dd>
Since this should only be called if the reply is still registered and replies auto-remove on a reply or error message, you should use the <a class="el" href="structadbus__Reply.html#a09dd7743ad0effcc67f42b6ebde095a6" title="Function to call when the reply is removed.">adbus_Reply::release</a> field to figure out if this needs to be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fabe2dd65fdc0b05a5571655dac6d08"></a><!-- doxytag: member="adbus_Connection::adbus_conn_send" ref="a0fabe2dd65fdc0b05a5571655dac6d08" args="(adbus_Connection *c, adbus_Message *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adbus_conn_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structadbus__Message.html">adbus_Message</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a message on the connection. </p>
<p>This function is thread safe and may be called in both callbacks and on other threads.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not call this is in method call callback for replies. Instead setup your response in the provided msg factory (<a class="el" href="structadbus__CbData.html#a2e03cbc6e63c07377e7b01c0ab4f961a" title="A message factory used for setting up returned messages.">adbus_CbData::ret</a>).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Actually make this thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a613ad9b713130293f3fb4e5824ae70d1"></a><!-- doxytag: member="adbus_Connection::adbus_conn_serial" ref="a613ad9b713130293f3fb4e5824ae70d1" args="(adbus_Connection *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t adbus_conn_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a serial that can be used for sending messages. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is thread safe and may be called in both callbacks and on other threads.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Actually make this thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="afeef1d5935553474b8f055dcde28c0ea"></a><!-- doxytag: member="adbus_Connection::adbus_conn_shouldproxy" ref="afeef1d5935553474b8f055dcde28c0ea" args="(adbus_Connection *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">adbus_Bool adbus_conn_shouldproxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Connection.html">adbus_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See if calling code should use <a class="el" href="structadbus__Connection.html#af26fb89e267785018a8e9eefa8195a78" title="Proxy a call over to the connection thread or call immediately if already on it.">adbus_conn_proxy()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>adbus_ConnectionCallbacks::should_proxy </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>adbus/connection.c</li>
<li>adbus/reply.c</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Mar 22 00:10:02 2010 for adbus by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
