<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>adbus: adbus_Buffer Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>adbus_Buffer Struct Reference</h1><!-- doxytag: class="adbus_Buffer" -->
<p>General purpose buffer and means to serialise dbus data with an associated signature.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a911b85d61795b021cb1597ef4a8fbf17"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_new" ref="a911b85d61795b021cb1597ef4a8fbf17" args="()" -->
<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a911b85d61795b021cb1597ef4a8fbf17">adbus_buf_new</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60ae1fbee644a9743a3d1ab573420dcb"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_free" ref="a60ae1fbee644a9743a3d1ab573420dcb" args="(adbus_Buffer *b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a60ae1fbee644a9743a3d1ab573420dcb">adbus_buf_free</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad881c83796bdd8f33db57b58a6d99dd9"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_data" ref="ad881c83796bdd8f33db57b58a6d99dd9" args="(const adbus_Buffer *b)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#ad881c83796bdd8f33db57b58a6d99dd9">adbus_buf_data</a> (const <a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current data in the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93014c4d593efdfeedb92b7c19e036e6"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_size" ref="a93014c4d593efdfeedb92b7c19e036e6" args="(const adbus_Buffer *b)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a93014c4d593efdfeedb92b7c19e036e6">adbus_buf_size</a> (const <a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the data in the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#abf4999c61f887d2e99aa2fcca6fa11a2">adbus_buf_release</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases the internal buffer and returns it.  <a href="#abf4999c61f887d2e99aa2fcca6fa11a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515">adbus_buf_reset</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the internal buffer.  <a href="#aaf96723d8b13b03e0f28613d15e71515"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb00f36e0006471afb4c3650df0f9413"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_sig" ref="acb00f36e0006471afb4c3650df0f9413" args="(const adbus_Buffer *b, size_t *size)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#acb00f36e0006471afb4c3650df0f9413">adbus_buf_sig</a> (const <a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t *size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current signature. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a924b80897d313396e4e85cf5b463761c">adbus_buf_signext</a> (const <a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t *size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the tracked point in the signature.  <a href="#a924b80897d313396e4e85cf5b463761c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a816b32854e69bd6779aee1e2b3e4b371"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_setsig" ref="a816b32854e69bd6779aee1e2b3e4b371" args="(adbus_Buffer *b, const char *sig, int size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371">adbus_buf_setsig</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, const char *sig, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the buffer signature. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39b4e648827cea279f16ff2233c12576"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_appendsig" ref="a39b4e648827cea279f16ff2233c12576" args="(adbus_Buffer *b, const char *sig, int size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a39b4e648827cea279f16ff2233c12576">adbus_buf_appendsig</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, const char *sig, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends to the buffer signature. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a441805cc89f8755cdcdb052ab9e10a50">adbus_buf_reserve</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserves a specified min amount of room in the buffer.  <a href="#a441805cc89f8755cdcdb052ab9e10a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c3a5513a50d461d6c1cbc2d8b68ce33"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_remove" ref="a3c3a5513a50d461d6c1cbc2d8b68ce33" args="(adbus_Buffer *b, size_t off, size_t num)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a3c3a5513a50d461d6c1cbc2d8b68ce33">adbus_buf_remove</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t off, size_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a chunk of data from the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6f596774ceb35dc5f0ae87572d1727"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_append" ref="a4d6f596774ceb35dc5f0ae87572d1727" args="(adbus_Buffer *b, const char *data, size_t sz)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a4d6f596774ceb35dc5f0ae87572d1727">adbus_buf_append</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, const char *data, size_t sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a chunk of data to the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a29a5432ce2fee1d9e538a96939309e2f">adbus_buf_line</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t *sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next newline terminated line at the start of the buffer.  <a href="#a29a5432ce2fee1d9e538a96939309e2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076">adbus_buf_recvbuf</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserves a buffer to directly append data.  <a href="#ae13fc6947d30b654f53eef1093391076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a42e3158b92b07b940de3fd141558b604">adbus_buf_recvd</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, size_t len, adbus_ssize_t recvd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears out the extra space not used by a <a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf()</a>.  <a href="#a42e3158b92b07b940de3fd141558b604"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2d4e27c491d33ce7e2ec2b839e5818"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_end" ref="aaa2d4e27c491d33ce7e2ec2b839e5818" args="(adbus_Buffer *b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#aaa2d4e27c491d33ce7e2ec2b839e5818">adbus_buf_end</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to end a series of serialised arguments. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd1e038e61e0172af85338280ad84d22"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_bool" ref="abd1e038e61e0172af85338280ad84d22" args="(adbus_Buffer *b, adbus_Bool v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#abd1e038e61e0172af85338280ad84d22">adbus_buf_bool</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, adbus_Bool v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a boolean (dbus sig "b"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b951c4df5b01ceee75e5006cc7bd3e5"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_u8" ref="a6b951c4df5b01ceee75e5006cc7bd3e5" args="(adbus_Buffer *b, uint8_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a6b951c4df5b01ceee75e5006cc7bd3e5">adbus_buf_u8</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, uint8_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a uint8_t (dbus sig "y"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68d6ffaaab994005f9c5dfbfd0ee410d"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_i16" ref="a68d6ffaaab994005f9c5dfbfd0ee410d" args="(adbus_Buffer *b, int16_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a68d6ffaaab994005f9c5dfbfd0ee410d">adbus_buf_i16</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, int16_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a int16_t (dbus sig "n"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaddcca3a4f19e0affda061942dc5d9bb"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_u16" ref="aaddcca3a4f19e0affda061942dc5d9bb" args="(adbus_Buffer *b, uint16_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#aaddcca3a4f19e0affda061942dc5d9bb">adbus_buf_u16</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, uint16_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a uint16_t (dbus sig "q"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a898fbd06f1e5cfd297888b4226a64686"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_i32" ref="a898fbd06f1e5cfd297888b4226a64686" args="(adbus_Buffer *b, int32_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a898fbd06f1e5cfd297888b4226a64686">adbus_buf_i32</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, int32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a int32_t (dbus sig "i"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4b6a20cfae8fdf755be90fe962ddbde"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_u32" ref="af4b6a20cfae8fdf755be90fe962ddbde" args="(adbus_Buffer *b, uint32_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#af4b6a20cfae8fdf755be90fe962ddbde">adbus_buf_u32</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, uint32_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a uint32_t (dbus sig "u"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39b29792f89b46382d8c8e36a81265ac"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_i64" ref="a39b29792f89b46382d8c8e36a81265ac" args="(adbus_Buffer *b, int64_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a39b29792f89b46382d8c8e36a81265ac">adbus_buf_i64</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, int64_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a int64_t (dbus sig "x"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07d68380c783baaaf2ecb5e87bd47385"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_u64" ref="a07d68380c783baaaf2ecb5e87bd47385" args="(adbus_Buffer *b, uint64_t v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a07d68380c783baaaf2ecb5e87bd47385">adbus_buf_u64</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, uint64_t v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a uint64_t (dbus sig "t"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb4c12506f15555eb9c8a14380c23bf5"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_double" ref="adb4c12506f15555eb9c8a14380c23bf5" args="(adbus_Buffer *b, double v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#adb4c12506f15555eb9c8a14380c23bf5">adbus_buf_double</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, double v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a double (dbus sig "d"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eff9a210908d66ec3368ffa87c26b9c"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_string" ref="a9eff9a210908d66ec3368ffa87c26b9c" args="(adbus_Buffer *b, const char *str, int size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a9eff9a210908d66ec3368ffa87c26b9c">adbus_buf_string</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, const char *str, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a string (dbus sig "s"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa9ec3b1578896b1b7355c20565995a"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_objectpath" ref="a1fa9ec3b1578896b1b7355c20565995a" args="(adbus_Buffer *b, const char *str, int size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a1fa9ec3b1578896b1b7355c20565995a">adbus_buf_objectpath</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, const char *str, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises an object path (dbus sig "o"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81bd75470aa4d87333f6813c8b7a7bf0"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_signature" ref="a81bd75470aa4d87333f6813c8b7a7bf0" args="(adbus_Buffer *b, const char *str, int size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a81bd75470aa4d87333f6813c8b7a7bf0">adbus_buf_signature</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, const char *str, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialises a signature (dbus sig "g"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c5ced08f5c47ce9a81b5530c36dfd3c"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_beginvariant" ref="a4c5ced08f5c47ce9a81b5530c36dfd3c" args="(adbus_Buffer *b, adbus_BufVariant *v, const char *sig, int size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a4c5ced08f5c47ce9a81b5530c36dfd3c">adbus_buf_beginvariant</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, adbus_BufVariant *v, const char *sig, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins a variant scope (dbus sig "v"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3adf36c0dc349af033a2e99dc23a1d23"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_endvariant" ref="a3adf36c0dc349af033a2e99dc23a1d23" args="(adbus_Buffer *b, adbus_BufVariant *v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a3adf36c0dc349af033a2e99dc23a1d23">adbus_buf_endvariant</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, adbus_BufVariant *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends a variant scope (dbus sig "v"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5e137302e38b359b36bc263edd8613d"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_beginarray" ref="ae5e137302e38b359b36bc263edd8613d" args="(adbus_Buffer *b, adbus_BufArray *a)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#ae5e137302e38b359b36bc263edd8613d">adbus_buf_beginarray</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, adbus_BufArray *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins an array scope (dbus sig "a"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1de2808488c8f48c8c793a38771e846a"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_arrayentry" ref="a1de2808488c8f48c8c793a38771e846a" args="(adbus_Buffer *b, adbus_BufArray *a)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a1de2808488c8f48c8c793a38771e846a">adbus_buf_arrayentry</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, adbus_BufArray *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins an array entry (dbus sig "a"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06cdefc352b2133e142cc8de329101f0"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_endarray" ref="a06cdefc352b2133e142cc8de329101f0" args="(adbus_Buffer *b, adbus_BufArray *a)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a06cdefc352b2133e142cc8de329101f0">adbus_buf_endarray</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b, adbus_BufArray *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends an array scope (dbus sig "a"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8abeef0be427903a3aa088343825a26"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_begindictentry" ref="ae8abeef0be427903a3aa088343825a26" args="(adbus_Buffer *b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#ae8abeef0be427903a3aa088343825a26">adbus_buf_begindictentry</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins a dict entry (dbus sig "{"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39a05caf7e1adfccaa70d385697a9da8"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_enddictentry" ref="a39a05caf7e1adfccaa70d385697a9da8" args="(adbus_Buffer *b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a39a05caf7e1adfccaa70d385697a9da8">adbus_buf_enddictentry</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends a dict entry (dbus sig "}"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59825fb488ca29763a6b8a33ae839ee1"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_beginstruct" ref="a59825fb488ca29763a6b8a33ae839ee1" args="(adbus_Buffer *b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a59825fb488ca29763a6b8a33ae839ee1">adbus_buf_beginstruct</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begins a struct (dbus sig "("). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f4220948ce2f810586f5dd714f5491"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_endstruct" ref="a38f4220948ce2f810586f5dd714f5491" args="(adbus_Buffer *b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a38f4220948ce2f810586f5dd714f5491">adbus_buf_endstruct</a> (<a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends a struct (dbus sig ")"). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa904c8a9dc616bd1b0585c821bdc5b5d"></a><!-- doxytag: member="adbus_Buffer::adbus_flip_value" ref="aa904c8a9dc616bd1b0585c821bdc5b5d" args="(char **data, size_t *size, const char **sig)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#aa904c8a9dc616bd1b0585c821bdc5b5d">adbus_flip_value</a> (char **data, size_t *size, const char **sig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Endian flips a single complete type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a830acdcb9d609fe181025e0b7e24301d"></a><!-- doxytag: member="adbus_Buffer::adbus_flip_data" ref="a830acdcb9d609fe181025e0b7e24301d" args="(char *data, size_t size, const char *sig)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadbus__Buffer.html#a830acdcb9d609fe181025e0b7e24301d">adbus_flip_data</a> (char *data, size_t size, const char *sig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Endian flips the entire buffer. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>General purpose buffer and means to serialise dbus data with an associated signature. </p>
<h2><a class="anchor" id="general">
Using as a General Buffer</a></h2>
<p>When being used as a general buffer data can be appended by using <a class="el" href="structadbus__Buffer.html#a4d6f596774ceb35dc5f0ae87572d1727" title="Appends a chunk of data to the buffer.">adbus_buf_append()</a> or <a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf()</a>; removed by using <a class="el" href="structadbus__Buffer.html#a3c3a5513a50d461d6c1cbc2d8b68ce33" title="Removes a chunk of data from the buffer.">adbus_buf_remove()</a>, <a class="el" href="structadbus__Buffer.html#abf4999c61f887d2e99aa2fcca6fa11a2" title="Releases the internal buffer and returns it.">adbus_buf_release()</a>, or <a class="el" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515" title="Clears the internal buffer.">adbus_buf_reset()</a>; and parsed with <a class="el" href="structadbus__Buffer.html#a29a5432ce2fee1d9e538a96939309e2f" title="Returns the next newline terminated line at the start of the buffer.">adbus_buf_line()</a>.</p>
<h2><a class="anchor" id="serialising">
Serialising DBus Data</a></h2>
<p>When being used for serialising dbus arguments, the signature must be set first with <a class="el" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371" title="Sets the buffer signature.">adbus_buf_setsig()</a> or <a class="el" href="structadbus__Buffer.html#a39b4e648827cea279f16ff2233c12576" title="Appends to the buffer signature.">adbus_buf_appendsig()</a> and then data can be serialised using the various <a class="el" href="structadbus__Buffer.html#abd1e038e61e0172af85338280ad84d22" title="Serialises a boolean (dbus sig &quot;b&quot;).">adbus_buf_bool()</a> etc functions.</p>
<p>The serialising functions all track the supplied signature and assert when the wrong serialise function is used. This tracked signature can then be pulled out via <a class="el" href="structadbus__Buffer.html#a924b80897d313396e4e85cf5b463761c" title="Returns the tracked point in the signature.">adbus_buf_signext()</a>. This is useful when serialising variant or typeless data.</p>
<p>The dbus data types which are scoped (array, dict entries, structs and variants) have a begin and end function and if needed use a struct in the calling code to maintain their scoped data.</p>
<h3><a class="anchor" id="arrays">
Arrays</a></h3>
<p>Array scopes are special in that multiple array entries can be added in an array. These entries can be added by either calling <a class="el" href="structadbus__Buffer.html#a1de2808488c8f48c8c793a38771e846a" title="Begins an array entry (dbus sig &quot;a&quot;).">adbus_buf_arrayentry()</a> before each entry or by appending the entire array data via <a class="el" href="structadbus__Buffer.html#a4d6f596774ceb35dc5f0ae87572d1727" title="Appends a chunk of data to the buffer.">adbus_buf_append()</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Array data appended using <a class="el" href="structadbus__Buffer.html#a4d6f596774ceb35dc5f0ae87572d1727" title="Appends a chunk of data to the buffer.">adbus_buf_append()</a> must have the correct alignment and have zero initialised padding.</dd></dl>
<p>Using <a class="el" href="structadbus__Buffer.html#a1de2808488c8f48c8c793a38771e846a" title="Begins an array entry (dbus sig &quot;a&quot;).">adbus_buf_arrayentry()</a> to serialise "ai" (an array of int32s):</p>
<div class="fragment"><pre class="fragment">  uint32_t data[] = {1, 2, 3};
  adbus_Array a;
  <a class="code" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515" title="Clears the internal buffer.">adbus_buf_reset</a>(buf);
  <a class="code" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371" title="Sets the buffer signature.">adbus_buf_setsig</a>(buf, <span class="stringliteral">&quot;ai&quot;</span>);
  <a class="code" href="structadbus__Buffer.html#ae5e137302e38b359b36bc263edd8613d" title="Begins an array scope (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_beginarray</a>(buf, &amp;a);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
  {
      <a class="code" href="structadbus__Buffer.html#a1de2808488c8f48c8c793a38771e846a" title="Begins an array entry (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_arrayentry</a>(buf, &amp;a);
      <a class="code" href="structadbus__Buffer.html#af4b6a20cfae8fdf755be90fe962ddbde" title="Serialises a uint32_t (dbus sig &amp;quot;u&amp;quot;).">adbus_buf_u32</a>(buf, data[i]);
  }
  <a class="code" href="structadbus__Buffer.html#a06cdefc352b2133e142cc8de329101f0" title="Ends an array scope (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_endarray</a>(buf, &amp;a);
</pre></div><p>Or equivalently using <a class="el" href="structadbus__Buffer.html#a4d6f596774ceb35dc5f0ae87572d1727" title="Appends a chunk of data to the buffer.">adbus_buf_append()</a>:</p>
<div class="fragment"><pre class="fragment">  uint32_t data[] = {1, 2, 3};
  adbus_Array a;
  <a class="code" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515" title="Clears the internal buffer.">adbus_buf_reset</a>(buf);
  <a class="code" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371" title="Sets the buffer signature.">adbus_buf_setsig</a>(buf, <span class="stringliteral">&quot;ai&quot;</span>);
  <a class="code" href="structadbus__Buffer.html#ae5e137302e38b359b36bc263edd8613d" title="Begins an array scope (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_beginarray</a>(buf, &amp;a);
  <a class="code" href="structadbus__Buffer.html#a4d6f596774ceb35dc5f0ae87572d1727" title="Appends a chunk of data to the buffer.">adbus_buf_append</a>(buf, data, <span class="keyword">sizeof</span>(data));
  <a class="code" href="structadbus__Buffer.html#a06cdefc352b2133e142cc8de329101f0" title="Ends an array scope (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_endarray</a>(buf, &amp;a);
</pre></div><h3><a class="anchor" id="dictentry">
Dict Entries</a></h3>
<p>Dict Entries can only be used as a scope directly inside an array. Thus the signature will always look like a{...}. The <a class="el" href="structadbus__Buffer.html#ae8abeef0be427903a3aa088343825a26" title="Begins a dict entry (dbus sig &quot;{&quot;).">adbus_buf_begindictentry()</a> call should occur after the <a class="el" href="structadbus__Buffer.html#a1de2808488c8f48c8c793a38771e846a" title="Begins an array entry (dbus sig &quot;a&quot;).">adbus_buf_arrayentry()</a>.</p>
<p>For example to serialise "a{is}" (a map of int32 to string):</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> std::map&lt;int, std::string&gt; Map;
  Map map;
  adbus_Array a;
  <a class="code" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515" title="Clears the internal buffer.">adbus_buf_reset</a>(buf);
  <a class="code" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371" title="Sets the buffer signature.">adbus_buf_setsig</a>(buf, <span class="stringliteral">&quot;a{is}&quot;</span>);
  <a class="code" href="structadbus__Buffer.html#ae5e137302e38b359b36bc263edd8613d" title="Begins an array scope (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_beginarray</a>(buf, &amp;a);
  <span class="keywordflow">for</span> (Map::const_iterator ii = map.begin(); ii != map.end(); ++ii)
  {
      <a class="code" href="structadbus__Buffer.html#a1de2808488c8f48c8c793a38771e846a" title="Begins an array entry (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_arrayentry</a>(buf, &amp;a);
      <a class="code" href="structadbus__Buffer.html#ae8abeef0be427903a3aa088343825a26" title="Begins a dict entry (dbus sig &amp;quot;{&amp;quot;).">adbus_buf_begindictentry</a>(buf);
      <a class="code" href="structadbus__Buffer.html#a898fbd06f1e5cfd297888b4226a64686" title="Serialises a int32_t (dbus sig &amp;quot;i&amp;quot;).">adbus_buf_i32</a>(buf, ii-&gt;first);
      <a class="code" href="structadbus__Buffer.html#a9eff9a210908d66ec3368ffa87c26b9c" title="Serialises a string (dbus sig &amp;quot;s&amp;quot;).">adbus_buf_string</a>(buf, ii-&gt;second.c_str(), -1);
      <a class="code" href="structadbus__Buffer.html#a39a05caf7e1adfccaa70d385697a9da8" title="Ends a dict entry (dbus sig &amp;quot;}&amp;quot;).">adbus_buf_enddictentry</a>(buf);
  }
  <a class="code" href="structadbus__Buffer.html#a06cdefc352b2133e142cc8de329101f0" title="Ends an array scope (dbus sig &amp;quot;a&amp;quot;).">adbus_buf_endarray</a>(buf, &amp;a);
</pre></div><h3><a class="anchor" id="struct">
Structs</a></h3>
<p>Structs are fairly straight forward. They simply have a begin and end function with no scoped data.</p>
<p>For example to serialise "(iis)" (a struct containing 2 int32s and a string):</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515" title="Clears the internal buffer.">adbus_buf_reset</a>(buf);
  <a class="code" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371" title="Sets the buffer signature.">adbus_buf_setsig</a>(buf, <span class="stringliteral">&quot;(iis)&quot;</span>);
  <a class="code" href="structadbus__Buffer.html#a59825fb488ca29763a6b8a33ae839ee1" title="Begins a struct (dbus sig &amp;quot;(&amp;quot;).">adbus_buf_beginstruct</a>(buf);
  <a class="code" href="structadbus__Buffer.html#a898fbd06f1e5cfd297888b4226a64686" title="Serialises a int32_t (dbus sig &amp;quot;i&amp;quot;).">adbus_buf_i32</a>(buf, first_number);
  <a class="code" href="structadbus__Buffer.html#a898fbd06f1e5cfd297888b4226a64686" title="Serialises a int32_t (dbus sig &amp;quot;i&amp;quot;).">adbus_buf_i32</a>(buf, second_number);
  <a class="code" href="structadbus__Buffer.html#a9eff9a210908d66ec3368ffa87c26b9c" title="Serialises a string (dbus sig &amp;quot;s&amp;quot;).">adbus_buf_string</a>(buf, <span class="keywordtype">string</span>, -1);
  <a class="code" href="structadbus__Buffer.html#a38f4220948ce2f810586f5dd714f5491" title="Ends a struct (dbus sig &amp;quot;)&amp;quot;).">adbus_buf_endstruct</a>(buf);
</pre></div><h3><a class="anchor" id="variant">
Variants</a></h3>
<p>Variants have a scoped struct to hold the original signature value and a begin function which takes the signature of the variant data.</p>
<p>For example to serialise "v" with a variant signature of "s" (string):</p>
<div class="fragment"><pre class="fragment">  adbus_Variant v;
  <a class="code" href="structadbus__Buffer.html#aaf96723d8b13b03e0f28613d15e71515" title="Clears the internal buffer.">adbus_buf_reset</a>(buf);
  <a class="code" href="structadbus__Buffer.html#a816b32854e69bd6779aee1e2b3e4b371" title="Sets the buffer signature.">adbus_buf_setsig</a>(buf, <span class="stringliteral">&quot;v&quot;</span>);
  <a class="code" href="structadbus__Buffer.html#a4c5ced08f5c47ce9a81b5530c36dfd3c" title="Begins a variant scope (dbus sig &amp;quot;v&amp;quot;).">adbus_buf_beginvariant</a>(buf, &amp;v, <span class="stringliteral">&quot;s&quot;</span>, -1);
  <a class="code" href="structadbus__Buffer.html#a9eff9a210908d66ec3368ffa87c26b9c" title="Serialises a string (dbus sig &amp;quot;s&amp;quot;).">adbus_buf_string</a>(buf, <span class="keywordtype">string</span>, -1);
  <a class="code" href="structadbus__Buffer.html#a3adf36c0dc349af033a2e99dc23a1d23" title="Ends a variant scope (dbus sig &amp;quot;v&amp;quot;).">adbus_buf_endvariant</a>(buf, &amp;v);
</pre></div> <hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a29a5432ce2fee1d9e538a96939309e2f"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_line" ref="a29a5432ce2fee1d9e538a96939309e2f" args="(adbus_Buffer *b, size_t *sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * adbus_buf_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next newline terminated line at the start of the buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>Buffer to work on </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sz</em>&nbsp;</td><td>Length of the returned line.</td></tr>
  </table>
  </dd>
</dl>
<p>This is mainly used for SASL auth protocol which is line based.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The returned line will not be null terminated. Instead use the size out param to determine its size.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL when there is no complete next line </dd></dl>

</div>
</div>
<a class="anchor" id="ae13fc6947d30b654f53eef1093391076"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_recvbuf" ref="ae13fc6947d30b654f53eef1093391076" args="(adbus_Buffer *b, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * adbus_buf_recvbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserves a buffer to directly append data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>Buffer to work on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Minimum length of returned buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This is most commonly used for getting a pointer to hand to recv style functions which write directly into the end of the provided buffer.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>You must call adbus_buf_recvd after receiving data to indicate how much was actually received before calling any other functions on the buffer.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structadbus__Buffer.html#a42e3158b92b07b940de3fd141558b604" title="Clears out the extra space not used by a adbus_buf_recvbuf().">adbus_buf_recvd</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42e3158b92b07b940de3fd141558b604"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_recvd" ref="a42e3158b92b07b940de3fd141558b604" args="(adbus_Buffer *b, size_t len, adbus_ssize_t recvd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adbus_buf_recvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adbus_ssize_t&nbsp;</td>
          <td class="paramname"> <em>recvd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears out the extra space not used by a <a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>Buffer to work on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Length supplied to <a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recvd</em>&nbsp;</td><td>Actual amount of data received.</td></tr>
  </table>
  </dd>
</dl>
<p>This should be called after receiving data into a buffer gotten via <a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf4999c61f887d2e99aa2fcca6fa11a2"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_release" ref="abf4999c61f887d2e99aa2fcca6fa11a2" args="(adbus_Buffer *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * adbus_buf_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the internal buffer and returns it. </p>
<p>After releasing the internal buffer, the user can do as they please with it, but must free it themselves. Note that since this will release the internal buffer, you will want to get the buffer size before releasing.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>To free the buffer you must use the same version of free as the library itself. For this reason use of this function is discouraged. </dd></dl>

</div>
</div>
<a class="anchor" id="a441805cc89f8755cdcdb052ab9e10a50"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_reserve" ref="a441805cc89f8755cdcdb052ab9e10a50" args="(adbus_Buffer *b, size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adbus_buf_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserves a specified min amount of room in the buffer. </p>
<p>This should only be used as a hint when the amount of room needed is known before adding the data. To actually reserve room at the end of the buffer to then right directly into use adbus_buf_recvbuf and adbus_buf_recvd.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structadbus__Buffer.html#ae13fc6947d30b654f53eef1093391076" title="Reserves a buffer to directly append data.">adbus_buf_recvbuf</a>, <a class="el" href="structadbus__Buffer.html#a42e3158b92b07b940de3fd141558b604" title="Clears out the extra space not used by a adbus_buf_recvbuf().">adbus_buf_recvd</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaf96723d8b13b03e0f28613d15e71515"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_reset" ref="aaf96723d8b13b03e0f28613d15e71515" args="(adbus_Buffer *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adbus_buf_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the internal buffer. </p>
<p>This does not free the internal buffer and thus is much better to use if you want to reuse the buffer than freeing and newing a new buffer.</p>
<p>A common idiom is to simply clear the buffer right before using it, but not bothering to clear it after you are finished using it. </p>

</div>
</div>
<a class="anchor" id="a924b80897d313396e4e85cf5b463761c"></a><!-- doxytag: member="adbus_Buffer::adbus_buf_signext" ref="a924b80897d313396e4e85cf5b463761c" args="(const adbus_Buffer *b, size_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * adbus_buf_signext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structadbus__Buffer.html">adbus_Buffer</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the tracked point in the signature. </p>
<p>As data is serialised into the buffer, the serialise functions will track along the signature. This returns the current point and thus the next expected field.</p>
<p>This can be very useful for binding to dynamic languages as you can use the buffer to track the required serialised signature, and then call signext to figure out which serialise function to call next. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>adbus/rbuffer.c</li>
<li>adbus/riterator.c</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Mar 22 00:10:02 2010 for adbus by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
